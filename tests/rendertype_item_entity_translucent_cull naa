#version 330

#moj_import <minecraft:fog.glsl>
#moj_import <minecraft:dynamictransforms.glsl>
#moj_import <minecraft:globals.glsl>

uniform sampler2D Sampler0;

in float sphericalVertexDistance;
in float cylindricalVertexDistance;
in vec4 vertexColor;
in vec2 texCoord0;
in vec2 texCoord1;
in vec3 vertexPosition;

out vec4 fragColor;

#define ALPHA_EFFECT(a) if(isTextureAlpha(a))

const float cloudscale = 1.1;
const float speed = 0.03;
const float clouddark = 0.5;
const float cloudlight = 0.3;
const float cloudcover = 0.2;
const float cloudalpha = 8.0;
const float skytint = 0.5;
const vec3 skycolour1 = vec3(0.2, 0.4, 0.6);
const vec3 skycolour2 = vec3(0.4, 0.7, 1.0);
const mat2 m = mat2(1.6, 1.2, -1.2, 1.6);

bool isTextureAlpha(float valueToExpected) {
    float epsilon = 1.0;
    float colorValue = texture(Sampler0, texCoord0).a * 255.0;
    return abs(colorValue - valueToExpected) < epsilon;
}

vec2 cloudHash(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float cloudNoise(in vec2 p) {
    const float K1 = 0.366025404;
    const float K2 = 0.211324865;
    vec2 i = floor(p + (p.x + p.y) * K1);
    vec2 a = p - i + (i.x + i.y) * K2;
    vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec2 b = a - o + K2;
    vec2 c = a - 1.0 + 2.0 * K2;
    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
    vec3 n = h * h * h * h * vec3(dot(a, cloudHash(i + 0.0)), dot(b, cloudHash(i + o)), dot(c, cloudHash(i + 1.0)));
    return dot(n, vec3(70.0));
}

float cloudFbm(vec2 n) {
    float total = 0.0, amplitude = 0.1;
    for (int i = 0; i < 7; i++) {
        total += cloudNoise(n) * amplitude;
        n = m * n;
        amplitude *= 0.4;
    }
    return total;
}

vec3 getMinecraftSkyWithClouds(vec3 rayDir) {
    vec2 uv = rayDir.xz / (abs(rayDir.y) + 0.2); 
    uv *= 0.3; 

    float time = GameTime*200 * speed;
    float q = cloudFbm(uv * cloudscale * 0.5);
    
    float r = 0.0;
    vec2 cloudUV = uv * cloudscale;
    cloudUV -= q - time;
    float weight = 0.8;
    for (int i = 0; i < 6; i++) {
        r += abs(weight * cloudNoise(cloudUV));
        cloudUV = m * cloudUV + time;
        weight *= 0.7;
    }
    
    float f = 0.0;
    cloudUV = uv * cloudscale;
    cloudUV -= q - time;
    weight = 0.7;
    for (int i = 0; i < 6; i++) {
        f += weight * cloudNoise(cloudUV);
        cloudUV = m * cloudUV + time;
        weight *= 0.6;
    }
    
    f *= r + f;
    
    float c = 0.0;
    time = GameTime*200 * speed * 2.0;
    cloudUV = uv * cloudscale * 2.0;
    cloudUV -= q - time;
    weight = 0.4;
    for (int i = 0; i < 5; i++) {
        c += weight * cloudNoise(cloudUV);
        cloudUV = m * cloudUV + time;
        weight *= 0.6;
    }
    
    float c1 = 0.0;
    time = GameTime*200 * speed * 3.0;
    cloudUV = uv * cloudscale * 3.0;
    cloudUV -= q - time;
    weight = 0.4;
    for (int i = 0; i < 5; i++) {
        c1 += abs(weight * cloudNoise(cloudUV));
        cloudUV = m * cloudUV + time;
        weight *= 0.6;
    }
    
    c += c1;
    
    float verticalGradient = rayDir.y * 0.5 + 0.5;
    vec3 skycolour = mix(skycolour2, skycolour1, verticalGradient);
    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight * c), 0.0, 1.0);
    
    f = cloudcover + cloudalpha * f * r;
    
    float cloudMask = smoothstep(0.15, 0.5, rayDir.y); 
    f *= cloudMask;
    c *= cloudMask;
    c1 *= cloudMask;
    
    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));
    
    return result;
}


#define iterations 17
#define formuparam 0.531

#define volsteps 20
#define stepsize 0.1

#define zoom   5.800
#define tile   0.850
#define speed  0.050 

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850
#define mouseX 0
#define mouseY 0.5

const float det=.003;
const float maxdist=30.;
float l=0.;
mat2 rotm;
vec3 basecol=vec3(.5,.5,1.);

mat3 lookat(vec3 dir, vec3 up){
    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));
    return mat3(rt,cross(rt,dir),dir);
}

mat2 rot2D(float a) {
    a=radians(a);
	float s=sin(a);
    float c=cos(a);
    return mat2(c,s,-s,c);
}


float de(vec3 p) {
    p.xz*=rot2D(mouseX*360.);
    p=abs(5.-mod(p+5.,10.));
    float md=100.;
    float s=1.25;
    float sc=1.;
    vec3 pc;
	vec3 mp=vec3(100.);
    float rot=sin(GameTime*200*.1)*20.;
    for (int i=0; i<8; i++) {
        p.xy=abs(p.xy); 
        p=p*s-1./sc;
        sc*=s;
        p.xz*=rotm;
        p.yz*=rot2D(30.+rot);
        float d=length(p.xz+sin(p.y)*.5)-.2/sc;
		mp=min(mp,abs(p));
        if (d<md) {
        	md=d;
			pc=p;
        }
    }
    l=mod(pc.y*.05-GameTime*200*.1,.5)*2.;
    return md/sc;
}

vec4 march(vec3 from, vec3 dir) {
	vec3 p;
    vec4 col=vec4(0.);
    float totdist=0., d;
    for (int i=0; i<40; i++) {
    	p=from+totdist*dir;
        d=de(p);
    	totdist+=max(det,d);
        if (totdist>maxdist||length(col)>.3) break;
        col+=max(0.,det-d)*l;
    }
	col=(col*2.5*vec4(0.94,0.427,1,1)*((30-totdist)/5))+(vec4(0.454, 0.113, 0.5,0)*0.2);
    return col;
}


// Star Nest by Pablo Roman Andrioli
// License: MIT

#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))


vec4 pen( vec3 rayDir ) {
    rotm=rot2D(-90.);
    vec3 dir=rayDir;
    vec3 from=vec3(1.,2.,-5.);
    from.xz*=rot2D(GameTime*200*3.);
    from.yz*=rot2D(GameTime*200);
    dir=lookat(-from,vec3(.5,1.,0.))*dir;
	vec4 colog=march(from, dir);   
    vec3 col = colog.rgb;
	col=mix(vec3(1.),col,min(1.,GameTime*200*.2));
    col=min(col,1);
    return vec4(col,colog.a);
	
}


vec4 stars( vec3 rayDir ) {
	//get coords and direction
	float time=GameTime*speed+.25;
	vec3 dir=rayDir/zoom;
	//mouse rotation
	float a1=0.5+mouseX/ScreenSize.x*2.0;
	float a2=0.8+mouseY/ScreenSize.y*2.0;
	mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));
	mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));
	dir.xz*=rot1;
	dir.xy*=rot2;
	vec3 from=vec3(1.,.5,0.5);
	from+=vec3(time*2.,time,-2.);
	from.xz*=rot1;
	from.xy*=rot2;
	
	//volumetric rendering
	float s=0.1,fade=1.;
	vec3 v=vec3(0.);
	for (int r=0; r<volsteps; r++) {
		vec3 p=from+s*dir*.5;
		p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold
		float pa,a=pa=0.;
		for (int i=0; i<iterations; i++) { 
			p=abs(p)/dot(p,p)-formuparam; // the magic formula
            // no glitter:
            // p=abs(p)/max(dot(p,p),0.0016)-formuparam;
			a+=abs(length(p)-pa); // absolute sum of average change
			pa=length(p);
		}
		float dm=max(0.,darkmatter-a*a*.001); //dark matter
		a*=a*a; // add contrast
		if (r>6) fade*=1.-dm; // dark matter, don't render near
		//v+=vec3(dm,dm*.5,0.);
		v+=fade;
		v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance
		fade*=distfading; // distance fading
		s+=stepsize;
	}
	v=mix(vec3(length(v)),v,saturation); //color adjust
	return vec4(v*.01,1.);	
	
}



void main() {
    vec4 color = texture(Sampler0, texCoord0) * vertexColor * ColorModulator;
    
    ALPHA_EFFECT(254) {
        vec3 viewDir = normalize(vertexPosition);
        vec3 clouds = getMinecraftSkyWithClouds(viewDir);
        vec2 uv = viewDir.xz / (abs(viewDir.y) + 0.2); 
        vec4 st = stars(viewDir);
        vec4 pe = pen(viewDir);
        fragColor = mix(st + pe, pe, pe.a);
        return;
    }
    
    if (color.a < 0.1) {
        discard;
    }
    
    fragColor = apply_fog(color, sphericalVertexDistance, cylindricalVertexDistance, FogEnvironmentalStart, FogEnvironmentalEnd, FogRenderDistanceStart, FogRenderDistanceEnd, FogColor);
}